{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5 lazy /^/.//.*/.entry/.js$/ groupOptions: {} namespace object","../node_modules/ionicons/dist/esm-es5 lazy /^/.//.*/.entry/.js$/ include: //.entry/.js$/ exclude: //.system/.entry/.js$/ groupOptions: {} namespace object","models/Setting.ts","Constants.ts","models/Note.ts","models/Tag.ts","models/TagNote.ts","models/Database.ts","components/Menu.tsx","components/Login.tsx","components/Editor/schema.ts","components/Editor/commands.ts","components/Editor/inputRules.ts","components/Editor/keyMappings.ts","components/Editor/index.tsx","components/Editor/afterTransaction.tsx","pages/Page.tsx","components/NotesList.tsx","routes.ts","pages/DefaultPage.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","keys","Object","module","exports","_settings","setSetting","key","value","oldSettings","getSettingsObj","newSettings","encryptedSettings","JSON","stringify","isPlatform","localStorage","setItem","Cookies","set","getSetting","isLoggedIn","undefined","cipherText","obj","getItem","get","parse","userEmail","apiToken","renewalToken","tokenExpiration","BACKEND_URL","GRAPHQL_URL","noteSchema","version","type","properties","primary","title","content","tagCount","trashed","updatedAt","format","insertedAt","indexes","notesCollection","name","schema","statics","getUntrashedNotes","this","find","where","eq","getUntaggedNotes","methods","trash","newDoc","atomicPatch","getDB","db","tagnotes","findForNote","forEach","tagnote","a","populate","tag","noteCount","untrash","GQL_ATTR_STR","formatGqlAttrs","tagSchema","tagsCollection","delete","remove","findByNameOrCreate","findOne","exec","create","genid","now","all","insert","getTag","tagId","migrationStrategies","tagNoteSchema","noteId","ref","position","_dbPromise","tagNoteCollection","getNotesForTag","sort","upsertNoteForTag","findNoteTag","noteTag","mappings","length","Date","toISOString","note","_createDB","addRxPlugin","require","createRxDatabase","adapter","multiInstance","addCollections","notes","tags","tagNotesCollection","setupHooks","RxDBReplicationGraphQLPlugin","RxDBMigrationPlugin","RxDBQueryBuilderPlugin","RxDBValidatePlugin","setInterval","expirationString","expiration","parseInt","getTime","console","log","axios","request","method","url","headers","authorization","response","data","access_token","renewal_token","expiresAt","toString","startOrUpdateReplication","catch","renewToken","replications","collection","pull","queryBuilder","doc","query","variables","push","state","tagNote","token","index","setHeaders","run","newState","syncGraphQL","deletedFlag","live","error$","subscribe","error","dir","userId","dbName","replace","uuidv1","innerJoin","left","right","keyLeft","keyRight","leftOuterJoin","pipe","lr","filter","combineLatest","idMap","Map","r","l","postInsert","_data","atomicUpdate","oldData","postRemove","concat","join","Menu","onLogout","onContextChange","context","currentContext","onTagChange","selectedTag","useState","setTags","untaggedCount","setUntaggedCount","useEffect","subs","tagsSub","$","untaggedSub","sub","unsubscribe","appPages","iosIcon","bulbOutline","mdIcon","count","trashOutline","className","style","display","flexDirection","expand","fill","size","color","onClick","appPage","slot","ios","md","Login","onSuccess","setContext","email","setEmail","password","setPassword","passwordConfirmation","setPasswordConfirmation","loginFailed","setLoginFailed","errorMessages","setErrorMessages","emailInput","useRef","login","post","user","password_confirmation","user_id","expires_at","messages","status","errors","field","changeContext","newCtx","setTimeout","current","setFocus","onSubmit","preventDefault","padding","textAlign","backgroundColor","margin","borderRadius","msg","idx","placeholder","onIonInput","target","onKeyUp","onIonChange","href","Schema","nodes","attrs","default","paragraph","group","spellcheck","parseDOM","toDOM","node","heading","level","defining","class","bulletList","listItem","underline","blockquote","horizontalRule","codeBlock","marks","preserveWhitespace","hardBreak","inline","selectable","hashTag","atom","isolating","draggable","getAttrs","dom","Element","getAttribute","image","src","alt","globalThis","text","strong","em","createHashTag","buildInputRules","nodeType","rules","smartQuotes","ellipsis","emDash","wrappingInputRule","ordered_list","match","order","childCount","orderedListRule","bulletListRule","textblockTypeInputRule","codeBlockRule","maxLevel","RegExp","headingRule","todoList","todoRule","regex","InputRule","start","end","nodeAt","tr","replaceRangeWith","insertText","tagRule","inputRules","mac","navigator","test","platform","buildKeymap","mapKeys","bind","cmd","mapped","undo","redo","undoInputRule","joinUp","joinDown","lift","selectParentNode","toggleMark","wrapInList","orderedList","wrapIn","br","chainCommands","exitCode","dispatch","replaceSelectionWith","scrollIntoView","splitListItem","liftListItem","sinkListItem","setBlockType","i","hr","createNoteDoc","Editor","useParams","setNote","Node","fromJSON","view","viewHost","saveNote","extractTitle","toJSON","createState","EditorState","plugins","history","keymap","anchor","selection","$anchor","nodeBefore","matches","textContent","to","pos","from","replaceWith","baseKeymap","firstChild","EditorView","dispatchTransaction","finalDoc","steps","step","stepDoc","docs","getMap","oldStart","oldEnd","newStart","newEnd","oldNodes","nodesBetween","oldNode","newNodes","newNode","includes","dbTag","updateState","apply","afterTransaction","focus","Selection","atEnd","setSelection","destroy","lastPosition","TextSelection","focusEndOfDoc","saveLoop","clearInterval","Page","onNoteIdChange","NotesList","selectedNoteId","useHistory","setNotes","callback","results","pairs","subscribeNotesForTag","notePairs","notesQuery","notesRes","addItem","formatRoute","show","useContextMenu","addCircleOutline","onContextMenu","event","props","animation","DefaultPage","App","setLoggedIn","notesContext","setNotesContext","setSelectedTag","setSelectedNoteId","contentId","ctx","path","render","exact","component","onCancel","Boolean","window","location","hostname","ReactDOM","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"qJAAA,IAAIA,EAAM,CACT,8BAA+B,CAC9B,IACA,GAED,uBAAwB,CACvB,IACA,GAED,uBAAwB,CACvB,IACA,GAED,0BAA2B,CAC1B,IACA,IAED,6BAA8B,CAC7B,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,wBAAyB,CACxB,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,sBAAuB,CACtB,IACA,IAED,uBAAwB,CACvB,IACA,IAED,4BAA6B,CAC5B,IACA,IAED,uBAAwB,CACvB,IACA,IAED,qBAAsB,CACrB,IACA,IAED,mCAAoC,CACnC,IACA,IAED,uBAAwB,CACvB,IACA,IAED,+BAAgC,CAC/B,IACA,IAED,wBAAyB,CACxB,IACA,IAED,yBAA0B,CACzB,IACA,IAED,wBAAyB,CACxB,IACA,IAED,uBAAwB,CACvB,IACA,GAED,uBAAwB,CACvB,IACA,IAED,yBAA0B,CACzB,IACA,GAED,8BAA+B,CAC9B,IACA,IAED,yBAA0B,CACzB,IACA,IAED,uBAAwB,CACvB,IACA,IAED,6BAA8B,CAC7B,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,+BAAgC,CAC/B,IACA,IAED,yBAA0B,CACzB,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,yBAA0B,CACzB,IACA,IAED,yBAA0B,CACzB,IACA,IAED,4BAA6B,CAC5B,IACA,IAED,2BAA4B,CAC3B,IACA,IAED,uBAAwB,CACvB,IACA,IAED,sBAAuB,CACtB,IACA,IAED,0BAA2B,CAC1B,IACA,IAED,uBAAwB,CACvB,IACA,IAED,wBAAyB,CACxB,IACA,IAED,gCAAiC,CAChC,IACA,KAGF,SAASC,EAAoBC,GAC5B,IAAIC,EAAoBC,EAAEJ,EAAKE,GAC9B,OAAOG,QAAQC,UAAUC,MAAK,WAC7B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBP,EAAM,KAEjD,MADAM,EAAEE,KAAO,mBACHF,KAIR,IAAIG,EAAMX,EAAIE,GAAMU,EAAKD,EAAI,GAC7B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","file":"static/js/main.36e71cc4.chunk.js","sourcesContent":["var map = {\n\t\"./ion-action-sheet.entry.js\": [\n\t\t610,\n\t\t5\n\t],\n\t\"./ion-alert.entry.js\": [\n\t\t611,\n\t\t6\n\t],\n\t\"./ion-app_8.entry.js\": [\n\t\t612,\n\t\t7\n\t],\n\t\"./ion-avatar_3.entry.js\": [\n\t\t613,\n\t\t17\n\t],\n\t\"./ion-back-button.entry.js\": [\n\t\t614,\n\t\t18\n\t],\n\t\"./ion-backdrop.entry.js\": [\n\t\t615,\n\t\t43\n\t],\n\t\"./ion-button_2.entry.js\": [\n\t\t616,\n\t\t19\n\t],\n\t\"./ion-card_5.entry.js\": [\n\t\t617,\n\t\t20\n\t],\n\t\"./ion-checkbox.entry.js\": [\n\t\t618,\n\t\t21\n\t],\n\t\"./ion-chip.entry.js\": [\n\t\t619,\n\t\t22\n\t],\n\t\"./ion-col_3.entry.js\": [\n\t\t620,\n\t\t44\n\t],\n\t\"./ion-datetime_3.entry.js\": [\n\t\t621,\n\t\t10\n\t],\n\t\"./ion-fab_3.entry.js\": [\n\t\t622,\n\t\t23\n\t],\n\t\"./ion-img.entry.js\": [\n\t\t623,\n\t\t45\n\t],\n\t\"./ion-infinite-scroll_2.entry.js\": [\n\t\t624,\n\t\t46\n\t],\n\t\"./ion-input.entry.js\": [\n\t\t625,\n\t\t24\n\t],\n\t\"./ion-item-option_3.entry.js\": [\n\t\t626,\n\t\t25\n\t],\n\t\"./ion-item_8.entry.js\": [\n\t\t627,\n\t\t26\n\t],\n\t\"./ion-loading.entry.js\": [\n\t\t628,\n\t\t27\n\t],\n\t\"./ion-menu_3.entry.js\": [\n\t\t629,\n\t\t28\n\t],\n\t\"./ion-modal.entry.js\": [\n\t\t630,\n\t\t8\n\t],\n\t\"./ion-nav_2.entry.js\": [\n\t\t631,\n\t\t14\n\t],\n\t\"./ion-popover.entry.js\": [\n\t\t632,\n\t\t9\n\t],\n\t\"./ion-progress-bar.entry.js\": [\n\t\t633,\n\t\t29\n\t],\n\t\"./ion-radio_2.entry.js\": [\n\t\t634,\n\t\t30\n\t],\n\t\"./ion-range.entry.js\": [\n\t\t635,\n\t\t31\n\t],\n\t\"./ion-refresher_2.entry.js\": [\n\t\t636,\n\t\t11\n\t],\n\t\"./ion-reorder_2.entry.js\": [\n\t\t637,\n\t\t16\n\t],\n\t\"./ion-ripple-effect.entry.js\": [\n\t\t638,\n\t\t47\n\t],\n\t\"./ion-route_4.entry.js\": [\n\t\t639,\n\t\t32\n\t],\n\t\"./ion-searchbar.entry.js\": [\n\t\t640,\n\t\t33\n\t],\n\t\"./ion-segment_2.entry.js\": [\n\t\t641,\n\t\t34\n\t],\n\t\"./ion-select_3.entry.js\": [\n\t\t642,\n\t\t35\n\t],\n\t\"./ion-slide_2.entry.js\": [\n\t\t643,\n\t\t48\n\t],\n\t\"./ion-spinner.entry.js\": [\n\t\t644,\n\t\t13\n\t],\n\t\"./ion-split-pane.entry.js\": [\n\t\t645,\n\t\t49\n\t],\n\t\"./ion-tab-bar_2.entry.js\": [\n\t\t646,\n\t\t36\n\t],\n\t\"./ion-tab_2.entry.js\": [\n\t\t647,\n\t\t15\n\t],\n\t\"./ion-text.entry.js\": [\n\t\t648,\n\t\t37\n\t],\n\t\"./ion-textarea.entry.js\": [\n\t\t649,\n\t\t38\n\t],\n\t\"./ion-toast.entry.js\": [\n\t\t650,\n\t\t39\n\t],\n\t\"./ion-toggle.entry.js\": [\n\t\t651,\n\t\t12\n\t],\n\t\"./ion-virtual-scroll.entry.js\": [\n\t\t652,\n\t\t50\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 335;\nmodule.exports = webpackAsyncContext;","var map = {\n\t\"./ion-icon.entry.js\": [\n\t\t654,\n\t\t57\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 337;\nmodule.exports = webpackAsyncContext;","import { isPlatform } from '@ionic/react'\nimport Cookies from 'js-cookie'\nimport CryptoJS from 'crypto-js'\n\nexport type Settings = {\n  userEmail?: string,\n  userId?: string,\n  apiToken?: string,\n  renewalToken?: string,\n  tokenExpiration?: string,\n}\n\ntype ValueOf<T> = T[keyof T]\n\nconst SETTINGS_COOKIE_KEY = 'settings'\n\n// obfuscated encryption key\nconst ENCRYPTION_KEY = 'D@D@343DZEcdEbhAC@#343CAS!df_##$='\n\n// for memoization\nlet _settings: Settings\n\nexport function setSetting(key: keyof Settings, value: ValueOf<Settings>): void {\n  const oldSettings = getSettingsObj()\n  if (oldSettings) {\n    const newSettings = {\n      ...oldSettings, [key]: value\n    }\n    _settings = newSettings \n    // const encryptedSettings = encrypt(newSettings)\n    const encryptedSettings = JSON.stringify(newSettings)\n    if (isPlatform('electron')) {\n      // btoa (base64) for weak obfuscation\n      localStorage.setItem(SETTINGS_COOKIE_KEY, encryptedSettings)\n    } else {\n      Cookies.set(SETTINGS_COOKIE_KEY, encryptedSettings)\n    }\n  }\n}\n\nexport function getSetting(key: keyof Settings): ValueOf<Settings> {\n  return getSettingsObj()[key]\n}\n\nexport function isLoggedIn(): boolean {\n  return getSetting('userEmail') !== undefined\n    && getSetting('apiToken') !== undefined\n    && getSetting('renewalToken') !== undefined\n    && getSetting('tokenExpiration') !== undefined\n}\n\nfunction getSettingsObj(): Settings {\n  if (_settings) {\n    return _settings\n  }\n\n  let cipherText: string | null\n  if (isPlatform('electron')) {\n    cipherText = localStorage.getItem(SETTINGS_COOKIE_KEY)\n  } else {\n    cipherText = Cookies.get(SETTINGS_COOKIE_KEY) || null\n  }\n  // const obj = cipherText && decrypt(cipherText)\n  const obj = cipherText && JSON.parse(cipherText)\n  if (!cipherText || !obj) {\n    return {\n      userEmail: undefined,\n      apiToken: undefined,\n      renewalToken: undefined,\n      tokenExpiration: undefined,\n    }\n  }\n\n  _settings = obj as Settings\n\n  return _settings\n}\n\nfunction encrypt(input: Settings): string {\n  return CryptoJS.AES.encrypt(JSON.stringify(input), ENCRYPTION_KEY).toString()\n}\n\nfunction decrypt(cipherText: string): Settings | null {\n  console.log('decrypted', CryptoJS.AES.decrypt(cipherText, ENCRYPTION_KEY))\n  const obj = JSON.parse(CryptoJS.AES.decrypt(cipherText, ENCRYPTION_KEY).toString())\n  if (obj)\n    return obj as Settings\n  else\n    return null\n}","export const BACKEND_URL =\n  process.env.NODE_ENV === 'production' ?\n    'https://todonotes.gigalixirapp.com' :\n    'http://localhost:4000'\n\nexport const FRONTEND_URL = 'https://todonotes.gigalixirapp.com'\nexport const GRAPHQL_URL = `${BACKEND_URL}/api/graphql`","import {\n  RxCollection,\n  RxCollectionCreator,\n  RxDocument,\n  RxJsonSchema,\n  RxQuery,\n  RxSchema,\n} from 'rxdb';\nimport { formatGqlAttrs, getDB } from './Database';\nimport { TagDocument } from './Tag';\n\nexport const noteSchema: RxJsonSchema<NoteDocType> = {\n  version: 0,\n  type: 'object',\n  // keyCompression: true,\n  properties: {\n    id: {\n      type: 'string',\n      primary: true,\n    },\n    title: {\n      type: 'string',\n    },\n    content: {\n      type: 'string',\n    },\n    tagCount: {\n      type: 'number',\n    },\n    trashed: {\n      type: 'boolean',\n    },\n    updatedAt: {\n      type: 'string',\n      format: 'date-time',\n    },\n    insertedAt: {\n      type: 'string',\n      format: 'date-time',\n    }\n  },\n  indexes: [\n    'id',\n    'insertedAt',\n  ]\n}\n\n\nconst noteCollectionMethods: NoteCollectionMethods = {\n  getUntrashedNotes: function (this: NoteCollection) {\n    return this.find().where('trashed').eq(false)\n  },\n  getUntaggedNotes(this: NoteCollection) {\n    return this.getUntrashedNotes().where('tagCount').eq(0)\n  }\n}\n\nconst noteDocMethods: NoteDocMethods = {\n  trash(this) {\n    const newDoc = this.atomicPatch({ trashed: true })\n    getDB().then(db => {\n      db.tagnotes.findForNote(this).then(tagnotes => {\n        tagnotes.forEach(async tagnote => {\n          const tag: TagDocument = await tagnote.populate('tagId')\n          tag.atomicPatch({\n            noteCount: tag.noteCount - 1,\n          })\n        })\n      })\n    })\n    return newDoc\n  },\n\n  untrash(this) {\n    const newDoc = this.atomicPatch({ trashed: false })\n    getDB().then(db => {\n      db.tagnotes.findForNote(this).then(tagnotes => {\n        tagnotes.forEach(async tagnote => {\n          const tag: TagDocument = await tagnote.populate('tagId')\n          tag.atomicPatch({\n            noteCount: tag.noteCount + 1,\n          })\n        })\n      })\n    })\n    return newDoc\n  }\n}\n\nexport const notesCollection: RxCollectionCreator = {\n  name: 'notes',\n  schema: noteSchema,\n  statics: noteCollectionMethods,\n  methods: noteDocMethods,\n}\n\n// *** TYPES ***\n\nexport type NoteId = string\n\nexport type NoteDocType = {\n  id: NoteId,\n  title: string,\n  content: string,\n  tagCount: number,\n  trashed: boolean,\n  updatedAt: string,\n  insertedAt: string,\n}\n\nexport type NoteDocument = RxDocument<NoteDocType, NoteDocMethods>\n\ntype NoteDocMethods = {\n  trash: (this: NoteDocument) => Promise<NoteDocument>\n  untrash: (this: NoteDocument) => Promise<NoteDocument>\n}\n\ntype NoteCollectionMethods = {\n  getUntrashedNotes: (this: NoteCollection) => RxQuery<NoteDocType, NoteDocument[]>\n  getUntaggedNotes: (this: NoteCollection) => RxQuery<NoteDocType, NoteDocument[]>\n}\n\nexport type NoteCollection = RxCollection<NoteDocType, NoteDocMethods, NoteCollectionMethods>\n\n// *** Replication ***\n\nconst GQL_ATTR_STR = formatGqlAttrs(noteSchema)\n\nexport const pullQueryBuilder = (doc: NoteDocument | { updatedAt: string }) => {\n  if (!doc) {\n    // the first pull does not have a start-document\n    doc = { updatedAt: (new Date(0).toISOString()) }\n  }\n  const query = `\n    {\n      queryNotesForReplication(minUpdatedAt: \"${doc.updatedAt}\") {\n        ${GQL_ATTR_STR}\n      }\n    }\n  `\n  return {\n    query,\n    variables: {}\n  }\n}\n\nexport const pushQueryBuilder = (doc: NoteDocument) => {\n  const query = `\n    mutation CreateNote($note: NoteInput) {\n      createNote(note: $note) {\n        ${GQL_ATTR_STR}\n      }\n    }\n  `\n  const variables = { note: doc }\n  return { query, variables }\n}\n","import {\n  RxCollection,\n  RxDocument,\n  RxJsonSchema,\n  RxQuery,\n} from 'rxdb';\nimport schema from '../components/Editor/schema';\nimport { formatGqlAttrs, genid, getDB, now } from './Database';\n\nexport const tagSchema: RxJsonSchema<TagDocType> = {\n  version: 0,\n  type: 'object',\n  // keyCompression: true,\n  properties: {\n    id: {\n      type: 'string',\n      primary: true,\n    },\n    name: {\n      type: 'string',\n    },\n    noteCount: {\n      type: 'integer',\n    },\n    insertedAt: {\n      type: 'string',\n      format: 'date-time',\n    },\n    updatedAt: {\n      type: 'string',\n      format: 'date-time',\n    },\n  },\n  indexes: [\n    'name'\n  ]\n}\n\n// export const ReservedTags = [\n//   'inbox'\n// ]\n\nexport const tagDocMethods: TagDocMethods = {\n  delete: async function (this: TagDocument) {\n    const db = await getDB()\n    // TODO: remove associations\n    this.remove()\n  },\n}\n\nexport const tagCollectionMethods: TagCollectionMethods = {\n  findByNameOrCreate: async function (this: TagCollection, name: string) {\n    const tag = await this.findOne().where('name').eq(name).exec()\n    if (tag)\n      return tag\n    return await this.create({\n      id: genid(),\n      name,\n      noteCount: 0,\n      insertedAt: now(),\n      updatedAt: now(),\n    })\n  },\n\n  all: function (this: TagCollection) {\n    return this.find()\n  },\n\n  create: function (this: TagCollection, tag: TagDocType) {\n    return this.insert(tag)\n  },\n\n  getTag: function (tagId: TagId) {\n    return this.findOne().where('tagId').eq(tagId).exec()\n  },\n}\n\nexport const tagsCollection = {\n  name: 'tags',\n  schema: tagSchema,\n  methods: tagDocMethods,\n  statics: tagCollectionMethods,\n  migrationStrategies: {\n  }\n}\n\n// *** TYPES ***\n\nexport type TagId = string\n\nexport type TagDocType = {\n  id: string,\n  name: string,\n  noteCount: number,\n  insertedAt: string,\n  updatedAt: string,\n}\n\nexport type TagDocMethods = {\n  delete: (this: TagDocument) => void,\n}\n\nexport type TagDocument = RxDocument<TagDocType, TagDocMethods>\n\nexport type TagCollectionMethods = {\n  findByNameOrCreate: (this: TagCollection, name: string) => Promise<TagDocument>\n  create: (this: TagCollection, tag: TagDocType) => Promise<TagDocument>\n  getTag: (this: TagCollection, tagId: TagId) => (Promise<TagDocument | null>)\n  all: (this: TagCollection) => RxQuery\n}\n\nexport type TagCollection = RxCollection<TagDocType, TagDocMethods, TagCollectionMethods>\n\n// REPLICATION\n\nconst GQL_ATTR_STR = formatGqlAttrs(tagSchema)\n\nexport const pullQueryBuilder = (doc: TagDocument | { updatedAt: string }) => {\n  if (!doc) {\n    // the first pull does not have a start-document\n    doc = { updatedAt: (new Date(0).toISOString()) }\n  }\n  const query = `\n    {\n      queryTagsForReplication(minUpdatedAt: \"${doc.updatedAt}\") {\n        ${GQL_ATTR_STR}\n      }\n    }\n  `\n  return {\n    query,\n    variables: {}\n  }\n}\n\nexport const pushQueryBuilder = (doc: TagDocument) => {\n  const query = `\n    mutation CreateTag($tag: TagInput) {\n      createTag(tag: $tag) {\n        ${GQL_ATTR_STR}\n      }\n    }\n  `\n  const variables = { tag: doc }\n  return { query, variables }\n}\n","import {\n  RxCollection,\n  RxDocument,\n  RxJsonSchema,\n  RxQuery,\n} from 'rxdb';\nimport { NoteId, NoteDocument } from './Note';\nimport { TagId, TagDocument } from './Tag';\nimport { formatGqlAttrs, genid, getDB, innerJoin, leftOuterJoin } from './Database';\nimport { Subscription } from 'rxjs';\n\nexport const tagNoteSchema: RxJsonSchema<TagNoteDocType> = {\n  version: 0,\n  type: 'object',\n  // keyCompression: true,\n  properties: {\n    id: {\n      type: 'string',\n      primary: true,\n    },\n    noteId: {\n      ref: 'notes',\n      type: 'string',\n    },\n    tagId: {\n      ref: 'tags',\n      type: 'string',\n    },\n    position: {\n      type: 'number',\n    },\n    insertedAt: {\n      type: 'string',\n      format: 'date-time',\n    },\n    updatedAt: {\n      type: 'string',\n      format: 'date-time',\n    },\n  },\n  indexes: [\n    \"tagId\",\n    \"position\",\n  ]\n}\n\nexport function subscribeNotesForTag(tag: TagDocument, callback: (notes: TagNotePair[]) => void): Subscription | null {\n  let sub: Subscription | null = null\n\n  getDB().then(db => {\n    sub = innerJoin(\n      db.notes.find().where('trashed').eq(false).$,\n      db.tagnotes.find().where('tagId').eq(tag?.id).$,\n      note => note.id,\n      tagNote => tagNote.noteId\n    ).subscribe(results => {\n      let pairs: TagNotePair[] = []\n      for (const [note, tagNote] of results) {\n        if (tagNote)\n          pairs.push([note, tagNote])\n      }\n      callback(pairs)\n    })\n  })\n  return sub\n}\n\nexport function subscribeUntaggedNotes(callback: (notes: NoteDocument[]) => void): Subscription | null {\n  let sub: Subscription | null = null\n  getDB().then(db => {\n    sub = leftOuterJoin(\n      db.notes.find().where('trashed').eq(false).$,\n      db.tagnotes.find().$,\n      note => note.id,\n      tagNote => tagNote.noteId\n    ).subscribe(results => {\n      const notes = results\n        .filter(([_, tagDoc]) => !tagDoc)\n        .map(([noteDoc, _]) => noteDoc)\n      callback(notes)\n    })\n  })\n  return sub\n}\n\n//*****/\n\nexport const tagNoteDocMethods: TagNoteDocMethods = {\n}\n\nexport const tagNoteCollectionMethods: TagNoteCollectionMethods = {\n  getNotesForTag: function (this: TagNoteCollection, tag: TagDocument) {\n    return this.find().where('tag').eq(tag.name).sort('position')\n  },\n  async upsertNoteForTag(this, tag, noteId) {\n\n    const noteTag = await this.findNoteTag(tag, noteId)\n    if (noteTag) return noteTag\n\n    const mappings = await this.getNotesForTag(tag).exec()\n    // const maxPosition = Math.max(...mappings.map(m => m.position))\n    // console.log('max pos', maxPosition)\n    return this.insert({\n      id: genid(),\n      noteId: noteId,\n      tagId: tag.id,\n      position: mappings.length,\n      insertedAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    })\n  },\n  findNoteTag(this, tag, noteId) {\n    return this.findOne().where('tagId').eq(tag.id).where('noteId').eq(noteId).exec()\n  },\n  findForNote(this, note) {\n    return this.find().where('noteId').eq(note.id).exec()\n  },\n}\n\nexport const tagNoteCollection = {\n  name: 'tagnotes',\n  schema: tagNoteSchema,\n  methods: tagNoteDocMethods,\n  statics: tagNoteCollectionMethods,\n  migrationStrategies: {\n  }\n}\n\nexport type TagNoteDocType = {\n  id: string,\n  noteId: NoteId,\n  tagId: TagId,\n  position: number,\n  insertedAt: string,\n  updatedAt: string,\n}\n\nexport type TagNoteDocMethods = {\n}\n\nexport type TagNoteMethods = {\n}\n\nexport type TagNoteDocument = RxDocument<TagNoteDocType, TagNoteMethods>\n\nexport type TagNoteCollectionMethods = {\n  getNotesForTag: (this: TagNoteCollection, tag: TagDocument) => RxQuery<TagNoteDocType, TagNoteDocument[]>,\n  upsertNoteForTag: (this: TagNoteCollection, tag: TagDocument, noteId: NoteId) => Promise<TagNoteDocument>,\n  findNoteTag: (this: TagNoteCollection, tag: TagDocument, noteId: NoteId) => Promise<TagNoteDocument | null>,\n  findForNote: (this: TagNoteCollection, note: NoteDocument) => Promise<TagNoteDocument[]>,\n}\n\nexport type TagNoteCollection = RxCollection<TagNoteDocType, TagNoteDocMethods, TagNoteCollectionMethods>\n\nexport type TagNotePair = [NoteDocument, TagNoteDocument]\n\n\n// REPLICATION\n\nconst GQL_ATTR_STR = formatGqlAttrs(tagNoteSchema)\n\nexport const pullQueryBuilder = (doc: TagNoteDocument | { updatedAt: string }) => {\n  if (!doc) {\n    // the first pull does not have a start-document\n    doc = { updatedAt: (new Date(0).toISOString()) }\n  }\n  const query = `\n    {\n      queryTagNotesForReplication(minUpdatedAt: \"${doc.updatedAt}\") {\n        ${GQL_ATTR_STR}\n      }\n    }\n  `\n  return {\n    query,\n    variables: {}\n  }\n}\n\nexport const pushQueryBuilder = (doc: TagDocument) => {\n  const query = `\n    mutation CreateTagNote($tagNote: TagNoteInput) {\n      createTagNote(tagNote: $tagNote) {\n        ${GQL_ATTR_STR}\n      }\n    }\n  `\n  const variables = { tagNote: doc }\n  return { query, variables }\n}","import {\n  createRxDatabase,\n  RxDatabase,\n  addRxPlugin,\n  GraphQLSyncPullOptions,\n  GraphQLSyncPushOptions,\n  RxReplicationState,\n  RxCollection,\n  RxJsonSchema,\n} from 'rxdb';\nimport { RxDBReplicationGraphQLPlugin, RxGraphQLReplicationState } from 'rxdb/plugins/replication-graphql';\nimport { v1 as uuidv1 } from 'uuid'\nimport { RxDBMigrationPlugin } from 'rxdb/plugins/migration'\nimport { RxDBQueryBuilderPlugin } from 'rxdb/plugins/query-builder'\nimport { RxDBValidatePlugin } from 'rxdb/plugins/validate'\nimport { Observable, combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { ItemCollection } from './Item';\nimport { setSetting, getSetting } from './Setting';\nimport axios from 'axios';\nimport { BACKEND_URL, GRAPHQL_URL } from '../Constants';\nimport {\n  NoteCollection,\n  notesCollection,\n  pushQueryBuilder as notesPush,\n  pullQueryBuilder as notesPull\n} from './Note'\nimport {\n  TagCollection,\n  tagsCollection,\n  pushQueryBuilder as tagsPush,\n  pullQueryBuilder as tagsPull,\n  TagDocument,\n} from './Tag';\nimport {\n  tagNoteCollection as tagNotesCollection,\n  TagNoteCollection,\n  pushQueryBuilder as tagNotesPush,\n  pullQueryBuilder as tagNotesPull,\n} from './TagNote';\n\naddRxPlugin(RxDBReplicationGraphQLPlugin)\naddRxPlugin(RxDBMigrationPlugin)\naddRxPlugin(RxDBQueryBuilderPlugin)\naddRxPlugin(RxDBValidatePlugin);\n\nlet _dbPromise: Promise<DB>;\n\nasync function _createDB(name: string): Promise<RxDatabase<DbCollections>> {\n\n  addRxPlugin(require('pouchdb-adapter-idb'))\n\n  const db = await createRxDatabase<DbCollections>({\n    name,\n    adapter: 'idb',\n    multiInstance: false,\n  })\n\n  await db.addCollections({\n    notes: notesCollection,\n    tags: tagsCollection,\n    tagnotes: tagNotesCollection,\n  })\n\n  setupHooks()\n\n  return db\n}\n\nfunction renewToken(renewalToken: string) {\n  axios.request({\n    method: 'POST',\n    url: `${BACKEND_URL}/api/v1/session/renew`,\n    headers: {\n      authorization: renewalToken\n    }\n  }).then(response => {\n    const { access_token, renewal_token } = response.data.data\n    const expiresAt = new Date().getTime() + 29 * 60 * 1000 // 29 minutes from now\n    setSetting('apiToken', access_token)\n    setSetting('renewalToken', renewal_token)\n    setSetting('tokenExpiration', expiresAt.toString())\n    startOrUpdateReplication()\n  }).catch(() => {\n    // setTimeout(() => renewToken(renewalToken), 5 * 60 * 1000) // retry in 5 minutes\n  })\n}\n\nsetInterval(() => {\n  const expirationString = getSetting('tokenExpiration')\n  const expiration = expirationString && parseInt(expirationString)\n  if (expiration && new Date().getTime() > expiration - 15 * 60 * 1000) { // 15 minutes\n    console.log(\"renewing token\")\n    const renewalToken = getSetting('renewalToken')\n    if (renewalToken) {\n      renewToken(renewalToken as string)\n    }\n  }\n}, 15 * 1000) // every 15 seconds\n\ninterface Replication {\n  collection: (db: RxDatabase<DbCollections>) => RxCollection,\n  pull: GraphQLSyncPullOptions,\n  push: GraphQLSyncPushOptions,\n  state: RxGraphQLReplicationState | null,\n}\n\nconst replications: Replication[] = [\n  {\n    collection: db => db.notes,\n    pull: { queryBuilder: notesPull },\n    push: { queryBuilder: notesPush },\n    state: null,\n  },\n  {\n    collection: db => db.tags,\n    pull: { queryBuilder: tagsPull },\n    push: { queryBuilder: tagsPush },\n    state: null,\n  },\n  {\n    collection: db => db.tagnotes,\n    pull: { queryBuilder: tagNotesPull },\n    push: { queryBuilder: tagNotesPush },\n    state: null,\n  }\n]\n\nexport function startOrUpdateReplication() {\n  getDB().then(db => {\n    const token = getSetting('apiToken') as string\n\n    if (token && token.length > 0) {\n\n      replications.forEach(({ collection, pull, push, state }, index) => {\n\n        if (state) {\n          state.setHeaders({ authorization: token })\n          state.run()\n        } else {\n          console.log(\"Setting up GraphQL sync...\")\n          const newState = collection(db).syncGraphQL({\n            url: GRAPHQL_URL,\n            headers: { authorization: token },\n            pull,\n            push,\n            deletedFlag: 'deleted',\n            live: true\n          })\n  \n          newState.error$.subscribe(error => {\n            console.log('something went wrong');\n            console.dir(error);\n          });\n\n          replications[index].state = newState\n        }\n      })\n\n    }\n  })\n}\n\nexport function stopReplication() {\n  replications.forEach(({ state }) => {\n    if (state) {\n      state.setHeaders({ authorization: '' })\n    }\n  })\n}\n\n// startOrUpdateReplication()\n\nexport async function getDB(): Promise<DB> {\n  const userId = getSetting('userId')\n  if (!_dbPromise && userId) {\n    const dbName = `notan_${userId.replace(/-/g, '_')}`\n    _dbPromise = _createDB(dbName)\n  }\n  // TODO: return promise error if userId not set yet\n  return _dbPromise\n}\n\nexport function genid() {\n  // const timestamp = new Date().getUTCMilliseconds();\n  // return sha256(timestamp.toString())\n  return uuidv1()\n}\n\nexport type DbCollections = {\n  // items: ItemCollection,\n  notes: NoteCollection,\n  tags: TagCollection,\n  tagnotes: TagNoteCollection,\n}\n\ntype DB = RxDatabase<DbCollections>\n\n\n// Utilities\n\n/* Inner Join Example:\n  innerJoin(\n    games.find().$,\n    platforms.find().$,\n    game => game.platform,\n    platform => platform.id\n  )\n  .subscribe( gamePlatforms => {\n      for( const [ game, platform ] of gamePlatforms ) {\n          console.log( game, platform );\n      }\n  } );\n*/\nexport const innerJoin = <T, U, K>(\n  left: Observable<ReadonlyArray<T>>,\n  right: Observable<ReadonlyArray<U>>,\n  keyLeft: (e: T) => K,\n  keyRight: (e: U) => K) =>\n\n  leftOuterJoin<T, U, K>(left, right, keyLeft, keyRight)\n    .pipe(\n      map(lr => lr.filter(([, r]) => r != null))\n    );\n\nexport const leftOuterJoin = <T, U, K>(\n  left: Observable<ReadonlyArray<T>>,\n  right: Observable<ReadonlyArray<U>>,\n  keyLeft: (e: T) => K,\n  keyRight: (e: U) => K) =>\n\n  combineLatest([left, right]).pipe(\n    map(\n      ([left, right]) => {\n        if (!left) return [];\n        if (!right) right = [];\n        const idMap = new Map<K, U>();\n        for (const r of right) idMap.set(keyRight(r), r);\n        return left.map(l => ([l, idMap.get(keyLeft(l))] as [T, U | undefined]));\n      }\n    )\n  );\n\nexport function now(): string {\n  return new Date().toISOString()\n}\n\n// middleware\n\nfunction setupHooks() {\n  getDB().then(db => {\n    db.tagnotes.postInsert((_data, doc) => {\n      db.tags.findOne(doc.tagId).exec().then(tag => {\n        tag?.atomicUpdate(oldData => ({\n          ...oldData,\n          noteCount: oldData.noteCount + 1,\n        }))\n      })\n      db.notes.findOne(doc.noteId).exec().then(note => {\n        note?.atomicUpdate(oldData => ({\n          ...oldData,\n          tagCount: oldData.tagCount + 1,\n        }))\n      })\n    }, false)\n  \n    db.tagnotes.postRemove((_data, doc) => {\n      db.tags.findOne(doc.tagId).exec().then(tag => {\n        tag?.atomicUpdate(oldData => ({\n          ...oldData,\n          noteCount: oldData.noteCount - 1,\n        }))\n      })\n      db.notes.findOne(doc.noteId).exec().then(note => {\n        note?.atomicUpdate(oldData => ({\n          ...oldData,\n          tagCount: oldData.tagCount - 1,\n        }))\n      })\n    }, false)\n  })\n}\n\nexport function formatGqlAttrs<T>(schema: RxJsonSchema): string {\n  return Object.keys(schema.properties)\n    .concat(['deleted'])\n    .join(\"\\n\")\n}","import {\n  IonButton,\n  IonContent,\n  IonIcon,\n  IonItem,\n  IonLabel,\n  IonList,\n  IonMenu,\n  IonMenuToggle,\n} from '@ionic/react';\n\nimport React, { useEffect, useState } from 'react';\nimport { bulbOutline, bookmarkOutline, trashOutline } from 'ionicons/icons';\nimport './Menu.css';\nimport { setSetting } from '../models/Setting';\nimport { getDB, stopReplication } from '../models/Database';\nimport { TagDocument } from '../models/Tag';\nimport { Subscription } from 'rxjs';\nimport { Context } from '../pages/Page';\n\ninterface AppPage {\n  iosIcon: string;\n  mdIcon: string;\n  title: string;\n  count: number | null;\n  context: Context;\n}\n\n\ninterface Props {\n  onLogout: () => void,\n  onContextChange: (ctx: Context) => void,\n  currentContext: Context,\n  onTagChange: (tag: TagDocument) => void,\n  selectedTag: TagDocument | null,\n}\nconst Menu: React.FC<Props> = ({ onLogout, onContextChange, currentContext: context, onTagChange, selectedTag }) => {\n  const [tags, setTags] = useState<TagDocument[]>([])\n  const [untaggedCount, setUntaggedCount] = useState<number | null>(null)\n\n  useEffect(() => {\n    let subs: Subscription[] = []\n    getDB().then(db => {\n      const tagsSub = db.tags.find().$.subscribe(tags => {\n        setTags(tags)\n      })\n      subs.push(tagsSub)\n\n      const untaggedSub = db.notes.getUntaggedNotes().$.subscribe(notes => {\n        setUntaggedCount(notes.length)\n      })\n      subs.push(untaggedSub)\n    })\n\n    return () => {\n      subs.forEach((sub: Subscription) => sub.unsubscribe())\n    }\n  }, [])\n\n  const appPages: AppPage[] = [\n    {\n      title: 'No Tags',\n      iosIcon: bulbOutline,\n      mdIcon: bulbOutline, \n      count: untaggedCount,\n      context: 'inbox',\n    },\n    {\n      title: 'Trash',\n      iosIcon: trashOutline,\n      mdIcon: trashOutline,\n      count: null,\n      context: 'trash',\n    },\n  ];\n\n  function logOut() {\n    stopReplication()\n    setSetting('userEmail', undefined)\n    setSetting('apiToken', undefined)\n    setSetting('renewalToken', undefined)\n    setSetting('tokenExpiration', undefined)\n    onLogout()\n  }\n\n  return (\n    <div className=\"menu\">\n\n        <div className=\"ion-padding-start\">\n          <div className=\"menu-header\" style={{ display: 'flex', flexDirection: 'column' }}>\n            <IonButton expand=\"block\" className=\"ion-align-self-center\" fill=\"clear\" size=\"small\" color=\"medium\" onClick={logOut}>logout</IonButton>\n          </div>\n        </div>\n\n        <div className=\"pages list\">\n          {appPages.map((appPage, index) => (\n            <div \n              key={index} \n              className={`page button ${appPage.context === context ? 'selected' : ''}`}\n              onClick={() => onContextChange(appPage.context)}\n            >\n              <IonIcon slot=\"start\" ios={appPage.iosIcon} md={appPage.mdIcon} />\n              <span className=\"content\">\n                {appPage.title}\n              </span>\n              <span className=\"count\">\n                {appPage.count}\n              </span>\n            </div>\n          ))}\n        </div>\n\n        <br />\n\n        <div className=\"tags list\">\n          {tags.map((tag, index) => (\n            <div \n              key={index} \n              className={`tag button ${context === 'tag' && selectedTag === tag ? 'selected' : ''}`}\n              onClick={() => {\n                onTagChange(tag)\n                onContextChange('tag')\n              }}\n            >\n              <span className=\"content\">\n                #{tag.name}\n              </span>\n              <span className=\"count\">\n                {tag.noteCount}\n              </span>\n            </div>\n          ))}\n        </div>\n\n    </div>\n  );\n};\n\nexport default Menu;\n","import { IonItem, IonInput, IonButton } from \"@ionic/react\"\nimport React, { useEffect, useRef, useState } from \"react\"\nimport axios from 'axios'\nimport { startOrUpdateReplication } from \"../models/Database\"\nimport { setSetting } from \"../models/Setting\"\nimport { BACKEND_URL } from \"../Constants\"\nimport './Login.css'\n\ninterface Props {\n  onSuccess: () => void,\n  onCancel: () => void,\n}\ntype Context = 'login' | 'registration'\n\nconst Login: React.FC<Props> = ({ onSuccess }) => {\n\n  const [context, setContext] = useState<Context>('login')\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n  const [passwordConfirmation, setPasswordConfirmation] = useState('')\n  const [loginFailed, setLoginFailed] = useState(false)\n  const [errorMessages, setErrorMessages] = useState<string[]>()\n  const emailInput = useRef<HTMLIonInputElement>(null)\n\n  useEffect(() => {\n    setTimeout(() => {\n      emailInput.current?.setFocus()\n    }, 500)\n  }, [])\n\n  function login() {\n    const url = context === 'login' ?\n      `${BACKEND_URL}/api/v1/session` :\n      `${BACKEND_URL}/api/v1/registration`\n\n    axios.post(\n      url,\n      { user: { email, password, password_confirmation: passwordConfirmation } } \n    ).then(response => {\n      const { access_token, renewal_token, user_id } = response.data.data\n      const expires_at = new Date().getTime() + 29 * 60 * 1000 // 29 minutes from now\n\n      setSetting('userId', user_id)\n      setSetting('tokenExpiration', expires_at.toString())\n      setSetting('userEmail', email)\n      setSetting('apiToken', access_token)\n      setSetting('renewalToken', renewal_token)\n      startOrUpdateReplication()\n\n      onSuccess()\n    }).catch(error => {\n      let messages\n      if (error.response.status === 401) {\n        messages = [\"Invalid email or password\"]\n      }\n      if (error.response.status === 500) {\n        const errors: { [key: string]: string } = error.response.data.error.errors\n        messages = Object.keys(errors).map(key => {\n          let field: string = key\n          if (key === 'password_confirmation') field = 'password'\n          return `${field} ${errors[key]}`\n        })\n      }\n      setLoginFailed(true)\n      setErrorMessages(messages)\n    })\n  }\n\n  function changeContext(newCtx: Context) {\n    setContext(newCtx)\n    setLoginFailed(false)\n  }\n\n  return (\n    <form id=\"loginForm\" onSubmit={e => {\n      e.preventDefault()\n      login()\n    }}>\n      {loginFailed &&\n        <div style={{ padding: '1em 1.7em', textAlign: 'left', backgroundColor: '#c88', color: '#fff', margin: 30, borderRadius: 11 }}>\n          {errorMessages?.map((msg, idx) => <div key={idx}>{msg}</div>)}\n        </div>\n      }\n      <IonItem>\n        <IonInput type=\"text\" name=\"email\" ref={emailInput} placeholder=\"Email\"\n          onIonInput={e => setEmail((e.target as HTMLInputElement).value)}\n          onKeyUp={e => e.key === 'Enter' && login()}\n        />\n      </IonItem>\n      <IonItem>\n        <IonInput type=\"password\" name=\"password\" placeholder=\"Password\"\n          onIonChange={e => setPassword((e.target as HTMLInputElement).value)}\n          onKeyUp={e => e.key === 'Enter' && login()}\n        />\n      </IonItem>\n      {context === 'registration' &&\n        <IonItem>\n          <IonInput type=\"password\" name=\"password_confirmation\" placeholder=\"Confirm Password\"\n            onIonChange={e => setPasswordConfirmation((e.target as HTMLInputElement).value)}\n            onKeyUp={e => e.key === 'Enter' && login()}\n          />\n        </IonItem>\n      }\n      <IonButton type=\"submit\" color=\"dark\">\n        {context === 'login' ? 'Login' : 'Register'}\n      </IonButton>\n\n      {context === 'login' ?\n        <a href=\"#\" onClick={() => changeContext('registration')}>Register</a> :\n        <a href=\"#\" onClick={() => changeContext('login')}>Login</a>\n      }\n    </form>\n  )\n}\n\nexport default Login","import {Schema} from \"prosemirror-model\"\n\ntype Nodes = \"doc\" | \"paragraph\" | \"heading\" | \"bulletList\" | \"listItem\" | \"underline\" | \"blockquote\" | \"horizontalRule\" | \"codeBlock\" | \"hardBreak\" | \"hashTag\" | \"image\" | \"text\"\n\ntype Marks = \"strong\" | \"em\"\n\nconst schema = new Schema<Nodes, Marks>({\n  nodes: {\n    doc: {\n      attrs: {\n        noteId: { default: null }\n      },\n      content: 'heading block+'\n    },\n    paragraph: {\n      group: 'block',\n      content: 'inline*',\n      attrs: {\n        spellcheck: { default: 'false' },\n      },\n      parseDOM: [{ tag: 'p' }],\n      toDOM(node) { return ['p', node.attrs, 0] }\n    },\n    heading: {\n      attrs: { level: { default: 1 } },\n      content: \"inline*\",\n      group: \"block\", // this seems to prevent second line to be non-heading\n      defining: false,\n      parseDOM: [\n        { tag: \"h1\", attrs: { level: 1 } },\n        { tag: \"h2\", attrs: { level: 2 } },\n        { tag: \"h3\", attrs: { level: 3 } },\n        { tag: \"h4\", attrs: { level: 4 } },\n        { tag: \"h5\", attrs: { level: 5 } },\n        { tag: \"h6\", attrs: { level: 6 } }\n      ],\n      toDOM(node) {\n        return [\n          \"h\" + node.attrs.level,\n          { class: 'heading', level: node.attrs.level },\n          0\n        ]\n      }\n    },\n    bulletList: {\n      group: 'block',\n      content: 'listItem+',\n      parseDOM: [{ tag: 'ul' }],\n      toDOM(node) { return ['ul', node.attrs, 0] }\n    },\n    listItem: {\n      defining: true,\n      content: 'paragraph block*',\n      parseDOM: [{ tag: 'li' }],\n      toDOM(node) { return ['li', node.attrs, 0] }\n    },\n    underline: {\n      group: 'block',\n      content: 'inline*',\n      attrs: {\n        spellcheck: { default: 'false' },\n      },\n      parseDOM: [{ tag: 'p' }],\n      toDOM(node) { return ['p', node.attrs, 0] }\n    },\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM() { return [\"blockquote\", 0]}\n    },\n    horizontalRule: {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM() { return [\"hr\"]}\n    },\n    // :: NodeSpec A code listing. Disallows marks or non-text inline\n    // nodes by default. Represented as a `<pre>` element with a\n    // `<code>` element inside of it.\n    codeBlock: {\n      content: \"text*\",\n      marks: \"\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      parseDOM: [{ tag: \"pre\", preserveWhitespace: \"full\" }],\n      toDOM() { return [\"pre\", [\"code\", 0]]}\n    },\n    hardBreak: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{ tag: \"br\" }],\n      toDOM() { return [\"br\"]}\n    },\n    hashTag: {\n      group: \"inline\",\n      inline: true,\n      atom: true,\n      content: 'text*',\n      isolating: true,\n\n      attrs: {\n        tag: { default: '' }\n      },\n\n      selectable: true,\n      draggable: false,\n\n      toDOM: node => {\n        return [\n          \"span\",\n          {\n            \"data-tag\": node.attrs.tag,\n            class: \"hashtag\",\n          },\n          `#${node.attrs.tag}` \n        ];\n      },\n\n      parseDOM: [\n        {\n          // match tag with following CSS Selector\n          tag: \"span[data-tag]\",\n\n          getAttrs: dom => {\n            var tag = dom instanceof Element ? dom.getAttribute(\"data-tag\") : ''\n            return {\n              tag: tag\n            };\n          }\n        }\n      ]\n    },\n    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n    // `alt`, and `href` attributes. The latter two default to the empty\n    // string.\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: { default: null },\n        title: { default: null }\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{\n        tag: \"img[src]\", getAttrs(dom) {\n          if (dom instanceof globalThis.Element) {\n            return {\n              src: dom.getAttribute(\"src\"),\n              title: dom.getAttribute(\"title\"),\n              alt: dom.getAttribute(\"alt\")\n            }\n\n          }\n        }\n      }],\n      toDOM(node) { let { src, alt, title } = node.attrs; return [\"img\", { src, alt, title }] }\n    },\n    text: {\n      group: 'inline'\n    },\n  },\n  marks: {\n    strong: {\n      parseDOM: [{ tag: 'b' }, { tag: 'strong' }],\n      toDOM(node) { return ['b', node.attrs, 0]}\n    },\n    em: {\n      parseDOM: [{ tag: 'em' }],\n      toDOM(node) { return ['em', node.attrs, 0]}\n    }\n  },\n})\n\nexport default schema\n\nexport type CustomSchema = typeof schema","import { Command } from \"prosemirror-commands\";\nimport { EditorState, Transaction } from \"prosemirror-state\";\nimport schema from \"./schema\";\n\nexport function createHashTagOnEnter(): Command {\n  return function (state: EditorState, dispatch: ((tr: Transaction) => void) | undefined) {\n    const anchor = state.tr.selection.$anchor\n    const nodeBefore = anchor.nodeBefore\n    if (nodeBefore?.type !== schema.nodes.text)\n      return false\n\n    const regex = \"[^|\\\\s]*#([\\\\w-]+)$\"\n    const matches = nodeBefore?.textContent.match(regex)\n    const content = matches ? matches[1] : ''\n\n    if (content.length === 0)\n      return false\n\n    const to = anchor.pos\n    const from = to - nodeBefore.textContent.length\n    if (dispatch) {\n      const hashTag = createHashTag(content)\n      dispatch(\n        state.tr.replaceWith(from, to, hashTag)\n          .insertText(' ')\n      )\n    }\n    return true\n  }\n}\n\nexport function createHashTag(content: string) {\n  const tag = schema.nodes.hashTag.create(\n    { tag: content },\n  )\n  return tag\n}\n\n// export function deleteHashTag() {\n\n//   return function (state: EditorState, dispatch: ((tr: Transaction<typeof schema>) => void) | undefined) {\n//     const anchor = state.tr.selection.$anchor\n//     const nodeBefore = anchor.nodeBefore\n//     let selectedNodes: Node[] = []\n//     state.tr.selection.content().content.descendants((node) => {\n//       selectedNodes.push(node)\n//     })\n//     if (nodeBefore?.type !== schema.nodes.hashTag)\n//       return false\n\n//     if (dispatch) {\n//       const to = anchor.pos\n//       const from = to - nodeBefore.nodeSize\n//       dispatch(state.tr.delete(from, to))\n//     }\n//     return true\n//   }\n// }\n\n// export function exitHashTag(nodeType: NodeType): Command<typeof schema> {\n//   return function (state: EditorState, dispatch: ((tr: Transaction<typeof schema>) => void) | undefined) {\n//     if (state.tr.selection.$to.node().type !== schema.nodes.hashTag)\n//       return false\n\n//     const curSelection = state.selection\n//     const afterPos = curSelection.$anchor.after()\n//     if (dispatch) {\n//       const spaceTr = state.tr.insertText(' ', afterPos)\n//       const moveCursorTr = spaceTr.setSelection(TextSelection.create(spaceTr.doc, afterPos + 0))\n//       // const delSpace = moveCursorTr//.delete(afterPos, afterPos + 0)\n\n//       dispatch(moveCursorTr)\n//       return true\n//     }\n\n//     return false\n//   }\n// }\n\n  // function backIntoHashTag(nodeType: NodeType): Command<any> {\n  //   /*\n  //     if prev node is hashtag || current node is hashtag\n\n  //   */\n  //   return function (state, dispatch) {\n  //     const curSelection = state.selection\n  //     const nodeBefore = state.tr.selection.$from.nodeBefore\n  //     const curNode = curSelection.$anchor.node()\n\n  //     console.log('node before type', nodeBefore?.type)\n  //     console.log('node current type', curNode?.type)\n  //     if (nodeBefore?.type !== nodeType && curNode.type !== nodeType)\n  //       return false\n\n  //     const beforePos = curSelection.$anchor.pos - 0\n  //     if (dispatch) {\n  //       // if last character in tag, delete whole tag\n  //       console.log('node type', curNode.type, 'length', curNode.textContent.length)\n\n  //       if (curNode.type === nodeType) {\n  //         if (curNode.textContent.length === 0) {\n  //           console.log('delete tag')\n  //           dispatch(state.tr.deleteRange(curSelection.anchor - 0, curSelection.anchor + 1))\n  //         }\n  //       } else {\n  //         console.log('delete end')\n  //         const delCharTr = state.tr.delete(beforePos - 0, beforePos)\n  //         const moveCursorTr = state.tr.setSelection(TextSelection.create(delCharTr.doc, beforePos))\n  //         dispatch(moveCursorTr)\n  //       }\n  //     }\n  //     return true\n  //   }\n  // }\n\n  // function deleteEmptyHashTag(nodeType: NodeType): Command<any> {\n  //   return function (state, dispatch) {\n  //     const nodeBefore = state.tr.selection.$from.nodeBefore\n  //     if (nodeBefore?.type !== nodeType)\n  //       return false\n\n  //     const curSelection = state.selection\n  //     const beforePos = curSelection.$anchor.pos - 0\n  //     if (dispatch) {\n  //       // const spaceTr = state.tr.insertText(' ', afterPos)\n  //       const moveCursorTr = state.tr.setSelection(TextSelection.create(state.tr.doc, beforePos))\n  //       // const delSpace = moveCursorTr.delete(afterPos, afterPos + 0)\n\n  //       const curNode = curSelection.$anchor.node()\n  //       console.log('cur node type', curNode.type, 'length', curNode.textContent.length)\n  //       if (curNode.type === nodeType && curNode.textContent.length === 0) {\n  //         console.log('delete tag')\n  //         dispatch(state.tr.deleteRange(curSelection.from - 1, curSelection.to + 1))\n  //       }\n  //     }\n  //     return true\n  //   }\n  // }\n\n  // export function parseTags(item: ItemDocument) {\n  //   getDB().then(db => {\n\n  //     // parse tags\n  //     const tagStrings = item.content.match(/#[a-z]+/gi)\n  //     if (tagStrings) {\n  //       tagStrings.forEach(async (tagString: string) => {\n  //         const tag = await db.tags.findByNameOrCreate(tagString.substring(1))\n  //         const existingTagItem = await db.tagitems.findOne().where('tag').eq(tag.name).where('item').eq(item.id).exec()\n  //         if (!existingTagItem)\n  //           db.tagitems.addItemForTag(tag, item)\n  //       });\n  //     }\n  //   })\n  // }\n\n  // const convertToTodo: CommandType = (state, dispatch) => {\n  //   const { $from } = state.selection\n  //   if (!state.selection.empty) return false\n\n  //   if (dispatch) {\n  //     dispatch(state.tr.replaceWith(\n  //       $from.start() - 1,\n  //       $from.end(),\n  //       TodoItemType.create({}, $from.parent.content))\n  //     )\n  //   }\n  //   return true\n  // }\n\n  // const convertToTag: CommandType = (state, dispatch) => {\n  //   const { $from } = state.selection\n  //   console.log('converting to tag')\n  //   if (!state.selection.empty) return false\n\n  //   if (dispatch) {\n  //     dispatch(state.tr.replaceWith(\n  //       $from.start() - 1,\n  //       $from.end(),\n  //       schema.nodes.tag.create({}, $from.parent.content))\n  //     )\n  //   }\n  //   return true\n  // }","\nimport {\n  inputRules, wrappingInputRule, textblockTypeInputRule,\n  smartQuotes, emDash, ellipsis, InputRule\n} from \"prosemirror-inputrules\"\nimport { NodeType, Schema } from \"prosemirror-model\"\nimport { createHashTag } from \"./commands\"\nimport schema from \"./schema\"\n\n// : (NodeType)  InputRule\n// Given a blockquote node type, returns an input rule that turns `\"> \"`\n// at the start of a textblock into a blockquote.\nexport function blockQuoteRule(nodeType: NodeType) {\n  return wrappingInputRule(/^\\s*>\\s$/, nodeType)\n}\n\n// : (NodeType)  InputRule\n// Given a list node type, returns an input rule that turns a number\n// followed by a dot at the start of a textblock into an ordered list.\nexport function orderedListRule(nodeType: NodeType) {\n  return wrappingInputRule(/^(\\d+)\\.\\s$/, nodeType, match => ({ order: +match[1] }),\n    (match, node) => node.childCount + node.attrs.order == +match[1])\n}\n\n// : (NodeType)  InputRule\n// Given a list node type, returns an input rule that turns a bullet\n// (dash, plush, or asterisk) at the start of a textblock into a\n// bullet list.\nexport function bulletListRule(nodeType: NodeType) {\n  return wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType)\n}\n\n// : (NodeType)  InputRule\n// Given a code block node type, returns an input rule that turns a\n// textblock starting with three backticks into a code block.\nexport function codeBlockRule(nodeType: NodeType) {\n  return textblockTypeInputRule(/^```$/, nodeType)\n}\n\n// : (NodeType, number)  InputRule\n// Given a node type and a maximum level, creates an input rule that\n// turns up to that number of `#` characters followed by a space at\n// the start of a textblock into a heading whose level corresponds to\n// the number of `#` signs.\nexport function headingRule(nodeType: NodeType, maxLevel: number) {\n  // return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"})\\\\s$\"),\n  return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"})\\\\s$\"),\n    nodeType, match => ({ level: match[1].length }))\n}\n\nexport function todoRule(nodeType: NodeType) {\n  return wrappingInputRule(/^\\s*(\\[ \\])\\s$/, nodeType)\n}\n\nexport function tagRule(nodeType: NodeType) {\n  // const regex = new RegExp(\"(^|\\\\s*)\" + '#' + \"([\\\\w-]+)\\\\s$\")\n  const regex = new RegExp(\"(^|\\\\s*)\" + '#' + \"([\\\\w-]+)\\\\s$\")\n  return new InputRule(regex, (state, match, start, end) => {\n    if (state.doc.nodeAt(start)?.type !== schema.nodes.text) {\n      return state.tr\n    }\n    const createTr = state.tr.replaceRangeWith(start, end,\n      createHashTag(match[2])\n    ).insertText(\" \")\n\n    // const moveCursorTr = createTr.setSelection(TextSelection.create(createTr.doc, start + 2))\n    return createTr\n  })\n}\n\n// : (Schema)  Plugin\n// A set of input rules for creating the basic block quotes, lists,\n// code blocks, and heading.\nexport function buildInputRules(schema: Schema) {\n  let rules = smartQuotes.concat(ellipsis, emDash), type\n  if (type = schema.nodes.blockquote) rules.push(blockQuoteRule(type))\n  if (type = schema.nodes.ordered_list) rules.push(orderedListRule(type))\n  if (type = schema.nodes.bulletList) rules.push(bulletListRule(type))\n  if (type = schema.nodes.codeBlock) rules.push(codeBlockRule(type))\n  if (type = schema.nodes.heading) rules.push(headingRule(type, 6))\n  if (type = schema.nodes.todoList) rules.push(todoRule(type))\n  if (type = schema.nodes.hashTag) rules.push(tagRule(type))\n  return inputRules({ rules })\n}\n","import {\n  wrapIn, setBlockType, chainCommands, toggleMark, exitCode,\n  joinUp, joinDown, lift, selectParentNode\n} from \"prosemirror-commands\"\nimport { wrapInList, splitListItem, liftListItem, sinkListItem } from \"prosemirror-schema-list\"\nimport { undo, redo } from \"prosemirror-history\"\nimport { undoInputRule } from \"prosemirror-inputrules\"\nimport { MarkType, NodeType, Schema } from \"prosemirror-model\"\nimport { CommandType } from './index'\n\nconst mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false\n\n// :: (Schema, ?Object)  Object\n// Inspect the given schema looking for marks and nodes from the\n// basic schema, and if found, add key bindings related to them.\n// This will add:\n//\n// * **Mod-b** for toggling [strong](#schema-basic.StrongMark)\n// * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)\n// * **Mod-`** for toggling [code font](#schema-basic.CodeMark)\n// * **Ctrl-Shift-0** for making the current textblock a paragraph\n// * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current\n//   textblock a heading of the corresponding level\n// * **Ctrl-Shift-Backslash** to make the current textblock a code block\n// * **Ctrl-Shift-8** to wrap the selection in an ordered list\n// * **Ctrl-Shift-9** to wrap the selection in a bullet list\n// * **Ctrl->** to wrap the selection in a block quote\n// * **Enter** to split a non-empty textblock in a list item while at\n//   the same time splitting the list item\n// * **Mod-Enter** to insert a hard break\n// * **Mod-_** to insert a horizontal rule\n// * **Backspace** to undo an input rule\n// * **Alt-ArrowUp** to `joinUp`\n// * **Alt-ArrowDown** to `joinDown`\n// * **Mod-BracketLeft** to `lift`\n// * **Escape** to `selectParentNode`\n//\n// You can suppress or map these bindings by passing a `mapKeys`\n// argument, which maps key names (say `\"Mod-B\"` to either `false`, to\n// remove the binding, or a new key name string.\nexport function buildKeymap(schema: Schema, mapKeys: { [key: string]: string | false }) {\n  let keys: { [key: string]: CommandType } = {}, type: NodeType | MarkType\n  function bind(key: string, cmd: CommandType) {\n    if (mapKeys) {\n      let mapped = mapKeys[key]\n      if (mapped === false) return\n      if (mapped) key = mapped\n    }\n    keys[key] = cmd\n  }\n\n\n  bind(\"Mod-z\", undo)\n  bind(\"Shift-Mod-z\", redo)\n  bind(\"Backspace\", undoInputRule)\n  if (!mac) bind(\"Mod-y\", redo)\n\n  bind(\"Alt-ArrowUp\", joinUp)\n  bind(\"Alt-ArrowDown\", joinDown)\n  bind(\"Mod-BracketLeft\", lift)\n  bind(\"Escape\", selectParentNode)\n\n  if (type = schema.marks.strong) {\n    bind(\"Mod-b\", toggleMark(type))\n    bind(\"Mod-B\", toggleMark(type))\n  }\n  if (type = schema.marks.em) {\n    bind(\"Mod-i\", toggleMark(type))\n    bind(\"Mod-I\", toggleMark(type))\n  }\n  if (type = schema.marks.code)\n    bind(\"Mod-`\", toggleMark(type))\n\n  if (type = schema.nodes.bulletList)\n    bind(\"Shift-Ctrl-8\", wrapInList(type))\n  if (type = schema.nodes.orderedList)\n    bind(\"Shift-Ctrl-9\", wrapInList(type))\n  if (type = schema.nodes.blockquote)\n    bind(\"Ctrl->\", wrapIn(type))\n  if (type = schema.nodes.hardBreak) {\n    let br = type, cmd = chainCommands(exitCode, (state, dispatch) => {\n      if (dispatch)\n        dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView())\n      return true\n    })\n    bind(\"Mod-Enter\", cmd)\n    bind(\"Shift-Enter\", cmd)\n    if (mac) bind(\"Ctrl-Enter\", cmd)\n  }\n  if (type = schema.nodes.listItem) {\n    bind(\"Enter\", splitListItem(type))\n    bind(\"Shift-Tab\", liftListItem(type))\n    bind(\"Tab\", sinkListItem(type))\n  }\n  if (type = schema.nodes.paragraph)\n    bind(\"Shift-Ctrl-0\", setBlockType(type))\n  if (type = schema.nodes.codeBlock)\n    bind(\"Shift-Ctrl-\\\\\", setBlockType(type))\n  if (type = schema.nodes.heading)\n    for (let i = 1; i <= 6; i++) bind(\"Shift-Ctrl-\" + i, setBlockType(type, { level: i }))\n  if (type = schema.nodes.horizontalRule) {\n    let hr = type\n    bind(\"Mod-_\", (state, dispatch) => {\n      if (dispatch)\n        dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView())\n      return true\n    })\n  }\n\n  return keys\n}","import React, { useEffect, useRef, useState } from 'react'\nimport { EditorState, Selection, TextSelection, Transaction } from \"prosemirror-state\"\nimport { EditorView } from \"prosemirror-view\"\nimport { Node, NodeType, Schema } from \"prosemirror-model\"\nimport { keymap } from \"prosemirror-keymap\"\nimport { undo, redo, history } from \"prosemirror-history\"\nimport { baseKeymap } from \"prosemirror-commands\"\nimport { exampleSetup } from 'prosemirror-example-setup'\nimport applyDevTools from \"prosemirror-dev-tools\";\nimport './Editor.css'\nimport { NoteDocument, NoteId } from '../../models/Note'\nimport schema from './schema'\nimport { useParams } from 'react-router'\nimport { getDB, now } from '../../models/Database'\nimport { buildInputRules } from './inputRules'\nimport { buildKeymap } from './keyMappings'\nimport { splitListItem, sinkListItem, liftListItem, wrapInList } from 'prosemirror-schema-list'\nimport { createHashTagOnEnter } from './commands'\nimport { afterTransaction } from './afterTransaction'\nimport { TagDocument } from '../../models/Tag'\n\ntype MySchema = typeof schema\n\nexport type CommandType<S extends Schema = any> = (\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n) => boolean\n\nlet TodoItemType: NodeType\nconst HashTagItemType = schema.nodes.hashTag\n\n\n// export const INITIAL_CONTENT = '{\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"spellcheck\":\"false\"}}]}'\nexport function createNoteDoc(noteId: NoteId, tag?: TagDocument) {\n  const tags = []\n  if (tag) {\n    tags.push(schema.nodes.hashTag.create({ tag: tag.name }))\n  }\n  const newDoc = schema.nodes.doc.create({ noteId }, [\n    schema.nodes.heading.create(),\n    schema.nodes.paragraph.create({}, tags) \n  ])\n  return newDoc\n}\n\ndeclare global {\n  interface Window {\n    view: any;\n  }\n}\n\ninterface Props {}\n\nconst Editor: React.FC<Props> = () => {\n  const { noteId } = useParams <{ noteId: string }>()\n  const [note, setNote] = useState<NoteDocument | null>(null)\n  let doc = note ? Node.fromJSON(schema, JSON.parse(note.content)) : createNoteDoc(noteId)\n  let view = useRef<EditorView>()\n  const viewHost = useRef<HTMLDivElement | null>(null)\n\n  useEffect(() => {\n    if (viewHost.current) {\n\n      view.current = new EditorView(viewHost.current, {\n        state: createState(doc),\n        dispatchTransaction(tr) {\n          afterTransaction(tr, view)\n        }\n      })\n      \n      if (view.current) {\n        view.current.focus()\n\n        // Move cursor to the end\n        const selection = Selection.atEnd(view.current.state.doc)\n        const tr = view.current.state.tr.setSelection(selection)\n        const state = view.current.state.apply(tr)\n        view.current.updateState(state)\n  \n        // window.view = view\n\n        // applyDevTools(view.current)\n      }\n\n    }\n\n    return () => {\n      saveNote()\n      view.current?.destroy()\n    }\n  }, [])\n\n  useEffect(() => {\n    if (noteId) {\n      getDB().then(async db => {\n        setNote(await db.notes.findOne(noteId).exec())\n      })\n    }\n  }, [noteId])\n\n\n\n  // when note prop changes\n  useEffect(() => {\n    if (view.current) {\n      view.current.updateState(createState(doc))\n      if (view.current) focusEndOfDoc(view.current)\n    }\n    const saveLoop = setInterval(() => {\n      saveNote()\n    }, 500) // every 0.5 second\n\n    return () => {\n      clearInterval(saveLoop)\n      saveNote()\n    }\n  }, [note])\n\n  function saveNote() {\n    if (view && note && view.current && (!view.current.state.doc.eq(doc))) {\n      doc = view.current.state.doc;\n      note.atomicPatch({\n        title: extractTitle(doc) || '',\n        content: JSON.stringify(doc.toJSON()),\n        updatedAt: now(),\n      })\n    }\n  }\n\n  function createState(doc: Node) {\n    return EditorState.create({\n      doc,\n      schema,\n      plugins: [\n        history(),\n        buildInputRules(schema),\n        keymap(buildKeymap(schema, {})),\n        keymap({\n          \"Enter\": createHashTagOnEnter(),\n        }),\n        keymap({ \"Mod-z\": undo, \"Mod-y\": redo }),\n        // keymap({ \"Mod-Enter\": convertToTodo }),\n        // keymap({ \"Mod-Enter\": convertToTag }),\n        // need separate mappings for TodoItem\n        // keymap({\n        //   \"Enter\": splitListItem(TodoItemType),\n        //   \"Tab\": sinkListItem(TodoItemType),\n        //   \"Shift-Tab\": liftListItem(TodoItemType),\n        // }),\n        keymap(baseKeymap),\n      ],\n    })\n  }\n\n  function extractTitle(doc: Node<MySchema>) {\n    return doc.firstChild?.textContent\n  }\n\n  function focusEndOfDoc(view: EditorView<any>) {\n    view.focus()\n    const tr = view.state.tr\n    const lastPosition = view.state.doc.content.size\n    const selection = TextSelection.create(tr.doc, lastPosition)\n    view.dispatch(tr.setSelection(selection))\n  }\n\n  return (\n    <div id=\"editor\" ref={viewHost}>\n      <div id=\"initContent\"></div>\n    </div>\n  )\n}\n\nexport default Editor\n","import { Transaction } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\nimport { Node } from \"prosemirror-model\";\nimport schema from './schema';\nimport { getDB } from '../../models/Database';\n\nexport function afterTransaction(tr: Transaction<any>, view: React.MutableRefObject<EditorView<any> | undefined>) {\n  const finalDoc = tr.doc;\n\n  const noteId = tr.doc.attrs.noteId\n\n  tr.steps.forEach((step, index) => {\n    const stepDoc = tr.docs[index];\n    step.getMap().forEach((oldStart, oldEnd, newStart, newEnd) => {\n\n      const oldNodes: Node[] = [];\n      stepDoc.nodesBetween(oldStart, oldEnd, oldNode => { oldNodes.push(oldNode); });\n      const newNodes: Node[] = [];\n      finalDoc.nodesBetween(newStart, newEnd, newNode => { newNodes.push(newNode); });\n\n      // Tag removed\n      stepDoc.nodesBetween(oldStart, oldEnd, oldNode => {\n        if (oldNode.type === schema.nodes.hashTag && !newNodes.includes(oldNode) && noteId) {\n          getDB().then(db => {\n            db.tags.findOne().where('name').eq(oldNode.attrs.tag).exec().then(dbTag => {\n              const tagNote = db.tagnotes.find()\n                .where('tagId').eq(dbTag?.id)\n                .where('noteId').eq(noteId);\n              tagNote.remove();\n            });\n          });\n        }\n      });\n\n      // Tag added \n      finalDoc.nodesBetween(newStart, newEnd, newNode => {\n        if (newNode.type === schema.nodes.hashTag && !oldNodes.includes(newNode) && noteId) {\n          console.log('add tag')\n          getDB().then(db => {\n            db.tags.findByNameOrCreate(newNode.attrs.tag).then(dbTag => {\n              db.tagnotes.upsertNoteForTag(dbTag, noteId);\n            });\n          });\n        }\n      });\n\n    });\n  });\n\n  view.current?.updateState(view.current.state.apply(tr));\n}\n","import React, { useEffect } from 'react';\nimport './Page.css';\nimport Editor from '../components/Editor';\nimport { NoteId } from '../models/Note';\nimport { useParams } from 'react-router';\n\nexport type Context = \"inbox\" | \"trash\" | \"tag\"\n\ninterface Props {\n  onNoteIdChange: (noteId: NoteId) => void\n}\nconst Page: React.FC<Props> = ({ onNoteIdChange }) => {\n  const { noteId } = useParams <{ noteId: string }>()\n\n  useEffect(() => {\n    onNoteIdChange(noteId)\n  }, [noteId, onNoteIdChange])\n\n  return (\n    <div className=\"note-container\">\n      <Editor />\n    </div>\n  );\n};\n\nexport default Page;\n","import React, { useEffect, useState } from 'react'\nimport { IonButton, IonIcon, IonItem, IonLabel, IonList } from '@ionic/react';\nimport { useHistory } from 'react-router-dom';\nimport { DbCollections, genid, getDB, now } from '../models/Database';\nimport { Subscription } from 'rxjs'\nimport { formatRoute } from 'react-router-named-routes';\nimport { Menu, Item, useContextMenu, ItemParams } from 'react-contexify';\nimport 'react-contexify/dist/ReactContexify.css';\nimport { NoteDocument, NoteId } from '../models/Note';\nimport { createNoteDoc } from './Editor';\nimport { NOTE_SHOW } from '../routes';\n\nimport './NotesList.css';\nimport { RxDatabase } from 'rxdb';\nimport { subscribeNotesForTag } from '../models/TagNote';\nimport { Context } from '../pages/Page'\nimport { TagDocument } from '../models/Tag';\nimport { addCircle, addCircleOutline } from 'ionicons/icons';\n\nconst MENU_ID = 'note_menu'\n\ninterface Props {\n  context: Context\n  selectedTag: TagDocument | null\n  selectedNoteId: NoteId | null\n}\n\nconst NotesList: React.FC<Props> = ({ context, selectedTag, selectedNoteId }) => {\n  const history = useHistory()\n\n  const [notes, setNotes] = useState<NoteDocument[]>([])\n\n  function notesQuery(db: RxDatabase<DbCollections>) {\n    return db.notes.find().where('trashed').eq(context === 'trash').sort({ insertedAt: 'desc' })\n  }\n\n  useEffect(() => {\n    let subs: Subscription[] = []\n    getDB().then(db => {\n      let sub\n      if (context === 'tag' && selectedTag) {\n        sub = subscribeNotesForTag(selectedTag, notePairs => {\n          setNotes(notePairs.map(([note, _]) => note))\n        })\n      } else if (context === 'inbox') {\n        // sub = subscribeUntaggedNotes(notes => {\n        //   setNotes(notes)\n        // })\n        sub = db.notes.getUntaggedNotes().$.subscribe(notes => {\n          setNotes(notes)\n        })\n      } else {\n        sub = notesQuery(db).$.subscribe(notesRes => {\n          if (!notesRes)\n            return\n          setNotes(notesRes)\n        })\n      }\n      if (sub) subs.push(sub)\n    })\n\n    return () => {\n      subs.forEach((sub: Subscription) => sub.unsubscribe())\n    }\n  }, [context, selectedTag])\n\n  const addItem = async (tag?: TagDocument) => {\n    const db = await getDB()\n    const id = genid()\n    const note = await db.notes.insert({\n      id: id,\n      title: \"Let's give this a title\",\n      content: JSON.stringify(createNoteDoc(id, tag)),\n      tagCount: 0,\n      trashed: false,\n      updatedAt: now(),\n      insertedAt: now(),\n    })\n    if (tag) {\n      await db.tagnotes.insert({\n        id: genid(),\n        tagId: tag.id,\n        noteId: note.id,\n        position: 0,\n        insertedAt: now(),\n        updatedAt: now(),\n      })\n    }\n    history.push(formatRoute(NOTE_SHOW, { noteId: id }))\n  }\n\n  const { show } = useContextMenu({\n    id: MENU_ID,\n  })\n\n  function handleContextMenu(event: React.MouseEvent<HTMLElement, MouseEvent>, noteId: string) {\n    show(event, {\n      props: {\n        noteId: noteId\n      },\n    })\n  }\n\n  function handleDelete({ props }: ItemParams) {\n    getDB().then(db => {\n      db.notes.findOne(props.noteId).exec().then(doc => {\n        doc?.trash()\n      })\n    })\n  }\n\n  function handlePermaDelete({ props }: ItemParams) {\n    getDB().then(db => {\n      db.notes.findOne(props.noteId).exec().then(doc => {\n        doc?.remove()\n      })\n    })\n  }\n\n  function handleRestore({ props }: ItemParams) {\n    getDB().then(db => {\n      db.notes.findOne(props.noteId).exec().then(doc => {\n        // doc?.atomicPatch({ trashed: false })\n        doc?.untrash()\n      })\n    })\n  }\n\n  return (\n    <div style={{ display: 'flex', flexDirection: 'column' }}>\n\n      <div className=\"notes\" style={{ color: '#fff' }}>\n        \n        <div \n          className=\"button new-note\"\n          onClick={() => addItem(selectedTag || undefined)}\n        >\n          <IonIcon ios={addCircleOutline} md={addCircleOutline} />\n        </div>\n\n        {notes.map(note =>\n          <div\n            key={note.id}\n            className={`button note ${selectedNoteId === note.id ? 'selected' : ''}`}\n            onClick={() => {\n              history.push(formatRoute(NOTE_SHOW, { noteId: note.id }))\n            }}\n            onContextMenu={e => {\n              e.preventDefault()\n              handleContextMenu(e, note.id)\n            }}\n          >\n            {note.title}\n          </div>\n          // <IonItem\n          //   lines=\"full\"\n          //   className={selectedNoteId === note.id ? 'selected' : ''}\n          //   key={note.id}\n          //   routerLink={formatRoute(\n          //     NOTE_SHOW,\n          //     { noteId: note.id }\n          //   )}\n          //   onContextMenu={e => {\n          //     e.preventDefault()\n          //     handleContextMenu(e, note.id)\n          //   }}\n          // >\n          //   <IonLabel slot='start'>{note.title}</IonLabel>\n          // </IonItem>\n        )}\n      </div>\n      {/* </IonList> */}\n      <Menu id={MENU_ID} animation={false}>\n        {context !== 'trash' &&\n          <Item onClick={handleDelete}>Delete</Item>\n        }\n        {context === 'trash' &&\n          <Item onClick={handleRestore}>Restore</Item>\n        }\n        {context === 'trash' &&\n          <Item onClick={handlePermaDelete}>Delete Forever</Item>\n        }\n      </Menu>\n    </div>\n  )\n}\n\nexport default NotesList","// export const TRASH_LIST = '/trash'\n// export const TRASH_SHOW = '/trash/:noteId'\n// export const TAG_NOTE_LIST = '/tag/:tagName'\n// export const TAG_NOTE_SHOW = '/tag/:tagName/:noteId'\n// export const INBOX_SHOW = '/inbox/:noteId'\n// export const INBOX_LIST = '/inbox'\nexport const NOTE_SHOW = '/notes/:noteId'","import React from 'react';\n\ninterface Props {}\nconst DefaultPage: React.FC<Props> = () => {\n  return (\n    <div style={{ padding: '2em 3em' }}>\n    </div>\n  )\n}\n\nexport default DefaultPage","import Menu from './components/Menu';\nimport React, { useEffect, useState } from 'react';\nimport { IonApp, IonRouterOutlet, IonSplitPane } from '@ionic/react';\nimport { IonReactRouter } from '@ionic/react-router';\nimport { Route } from 'react-router-dom';\n\n/* Core CSS required for Ionic components to work properly */\nimport '@ionic/react/css/core.css';\n\n/* Basic CSS for apps built with Ionic */\nimport '@ionic/react/css/normalize.css';\nimport '@ionic/react/css/structure.css';\nimport '@ionic/react/css/typography.css';\n\n/* Optional CSS utils that can be commented out */\nimport '@ionic/react/css/padding.css';\nimport '@ionic/react/css/float-elements.css';\nimport '@ionic/react/css/text-alignment.css';\nimport '@ionic/react/css/text-transformation.css';\nimport '@ionic/react/css/flex-utils.css';\nimport '@ionic/react/css/display.css';\n\n/* Theme variables */\nimport './theme/variables.css';\nimport './App.css'\nimport { NOTE_SHOW } from './routes';\nimport { isLoggedIn } from './models/Setting';\nimport Login from './components/Login';\nimport { startOrUpdateReplication } from './models/Database';\nimport Page, { Context } from './pages/Page'\nimport NotesList from './components/NotesList';\nimport { TagDocument } from './models/Tag';\nimport DefaultPage from './pages/DefaultPage';\nimport { NoteId } from './models/Note';\n\nconst App: React.FC = () => {\n\n  const [, setLoggedIn] = useState(isLoggedIn())\n  const [notesContext, setNotesContext] = useState<Context>('inbox')\n  const [selectedTag, setSelectedTag] = useState<TagDocument | null>(null)\n  const [selectedNoteId, setSelectedNoteId] = useState<NoteId | null>(null)\n\n  useEffect(() => {\n    if (isLoggedIn())\n      startOrUpdateReplication()\n  }, [])\n\n  return (\n    <IonApp>\n      {!isLoggedIn() ?\n\n        <Login\n          onSuccess={() => setLoggedIn(true)}\n          onCancel={() => {}}\n        /> :\n\n        <IonReactRouter>\n          <IonSplitPane contentId=\"main\">\n            <Menu\n              onLogout={() => setLoggedIn(false)}\n              onContextChange={ctx => setNotesContext(ctx)}\n              currentContext={notesContext}\n              onTagChange={tag => setSelectedTag(tag)}\n              selectedTag={selectedTag}\n            />\n            <NotesList context={notesContext} selectedTag={selectedTag} selectedNoteId={selectedNoteId} />\n            <IonRouterOutlet id=\"main\">\n              {/* <Route path={INBOX_LIST} render={props => <Page {...props} context='inbox' />} exact />\n              <Route path={INBOX_SHOW} render={props => <Page {...props} context='inbox' />} exact />\n              <Route path={TRASH_LIST}  render={props => <Page {...props} context='trash' />} exact />\n              <Route path={TRASH_SHOW}  render={props => <Page {...props} context='trash' />} exact />\n              <Route path={TAG_NOTE_LIST} render={props => <Page {...props} context='tag' />} exact />\n              <Route path={TAG_NOTE_SHOW} render={props => <Page {...props} context='tag' />} exact /> */}\n              <Route path={NOTE_SHOW} render={props => <Page {...props} onNoteIdChange={setSelectedNoteId} />} exact />\n              <Route path='/' component={DefaultPage} exact />\n            </IonRouterOutlet>\n          </IonSplitPane>\n        </IonReactRouter>\n      }\n    </IonApp>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}